folder "libracomp -- lib" {
  C_arg(Psi_0ls) = arctan(Psi_0ls.y, Psi_0ls.x) @{ color: "#c74440" }

  C_abs(Psi_0ls) = sqrt(Psi_0ls.x ^ 2 + Psi_0ls.y ^ 2) @{ color: "#388c46" }

  C_pdt(Psi_0ls, Psi_0x) =
    (
      Psi_0ls.x * Psi_0x.x - Psi_0ls.y * Psi_0x.y,
      Psi_0ls.x * Psi_0x.y + Psi_0x.x * Psi_0ls.y
    ) @{ color: "#6042a6" }

  C_qnt(Psi_0ls, Psi_0x) =
    (
      (Psi_0ls.x * Psi_0x.x + Psi_0ls.y * Psi_0x.y) /
        (Psi_0x.x ^ 2 + Psi_0x.y ^ 2),
      (Psi_0ls.y * Psi_0x.x - Psi_0ls.x * Psi_0x.y) /
        (Psi_0x.x ^ 2 + Psi_0x.y ^ 2)
    ) @{ color: "#388c46" }

  C_exp(Psi_0ls) =
    (e ^ Psi_0ls.x * cos(Psi_0ls.y), e ^ Psi_0ls.x * sin(Psi_0ls.y)) @{
    color: "#6042a6",
  }

  C_plg(Psi_0ls) =
    (ln(sqrt(Psi_0ls.x ^ 2 + Psi_0ls.y ^ 2)), arctan(Psi_0ls.y, Psi_0ls.x)) @{
    color: "#000000",
  }

  C_pow(Psi_0ls, Psi_0x) =
    C_exp(
      (
        Psi_0x.x * ln(sqrt(Psi_0ls.x ^ 2 + Psi_0ls.y ^ 2)) -
          Psi_0x.y * arctan(Psi_0ls.y, Psi_0ls.x),
        Psi_0x.y * ln(sqrt(Psi_0ls.x ^ 2 + Psi_0ls.y ^ 2)) +
          Psi_0x.x * arctan(Psi_0ls.y, Psi_0ls.x)
      )
    ) @{ color: "#c74440" }

  C_sin(Psi_0ls) =
    (sin(Psi_0ls.x) * cosh(Psi_0ls.y), cos(Psi_0ls.x) * sinh(Psi_0ls.y)) @{
    color: "#6042a6",
  }

  C_cos(Psi_0ls) =
    (cos(Psi_0ls.x) * cosh(Psi_0ls.y), -sin(Psi_0ls.x) * sinh(Psi_0ls.y)) @{
    color: "#388c46",
  }

  C_cnj(Psi_0ls) = (Psi_0ls.x, -Psi_0ls.y) @{ color: "#2d70b3" }

  C_gma(Psi_0ls) =
    (
      Psi_0ls.y * 0 +
        (
          integral x=(0 ... infty)
          (e ^ -x * (C_pow((x, 0), (Psi_0ls.x - 1, Psi_0ls.y))).x)
        ),
      (
        integral x=(0 ... infty)
        (e ^ -x * (C_pow((x, 0), (Psi_0ls.x - 1, Psi_0ls.y))).y)
      )
    ) @{ color: "#000000" }

  C_tan(Psi_0ls) = C_qnt(C_sin(Psi_0ls), C_cos(Psi_0ls)) @{ color: "#388c46" }

  C_cot(Psi_0ls) = C_qnt(C_cos(Psi_0ls), C_sin(Psi_0ls)) @{ color: "#000000" }

  C_sec(Psi_0ls) = C_qnt((1, 0), C_cos(Psi_0ls)) @{ color: "#6042a6" }

  C_csc(Psi_0ls) = C_qnt((1, 0), C_sin(Psi_0ls)) @{ color: "#2d70b3" }

  C_sinh(Psi_0ls) = C_pdt(C_sin(C_pdt(Psi_0ls, (0, 1))), (0, -1)) @{
    color: "#6042a6",
  }

  C_cosh(Psi_0ls) = C_cos(C_pdt(Psi_0ls, (0, 1))) @{ color: "#2d70b3" }

  C_tanh(Psi_0ls) = C_qnt(C_sinh(Psi_0ls), C_cosh(Psi_0ls)) @{
    color: "#2d70b3",
  }

  C_coth(Psi_0ls) = C_qnt(C_cosh(Psi_0ls), C_sinh(Psi_0ls)) @{
    color: "#6042a6",
  }

  C_sech(Psi_0ls) = C_qnt((1, 0), C_cosh(Psi_0ls)) @{ color: "#c74440" }

  C_csch(Psi_0ls) = C_qnt((1, 0), C_sinh(Psi_0ls)) @{ color: "#388c46" }

  C_asin(Psi_0ls) =
    C_pdt(
      (0, -1),
      C_plg(
        C_pdt((0, 1), Psi_0ls) +
          C_pow((1, 0) - C_pow(Psi_0ls, (2, 0)), (1 / 2, 0))
      )
    ) @{ color: "#c74440" }

  C_acos(Psi_0ls) =
    C_pdt(
      (0, 1),
      C_plg(
        Psi_0ls -
          C_pdt((0, 1), C_pow((1, 0) - C_pow(Psi_0ls, (2, 0)), (1 / 2, 0)))
      )
    ) @{ color: "#2d70b3" }

  C_asinh(Psi_0ls) = C_acosh(C_pdt(i, Psi_0ls)) @{ color: "#c74440" }

  C_rzt(Psi_0ls) =
    C_pdt(
      C_qnt((1, 0), C_gma(Psi_0ls)),
      (
        (
          integral x=(0 ... infty)
          ((C_pow((x, 0), (Psi_0ls.x - 1, Psi_0ls.y))).x / (e ^ x - 1))
        ),
        (
          integral x=(0 ... infty)
          ((C_pow((x, 0), (Psi_0ls.x - 1, Psi_0ls.y))).y / (e ^ x - 1))
        )
      )
    ) @{ color: "#6042a6" }

  C_log(Psi_0ls, Psi_0x) = C_qnt(C_plg(Psi_0ls), C_plg(Psi_0x)) @{
    color: "#c74440",
  }

  R_gma(Psi_0ls) = (Psi_0ls - 1)! @{ color: "#6042a6", hidden: true }

  R_dgm(Psi_0ls) = R_gma'(Psi_0ls) / R_gma(Psi_0ls) @{
    color: "#2d70b3",
    hidden: true,
  }

  g_amma = -(integral x=(0 ... 1) (ln(ln(1 / x)))) @{ color: "#c74440" }

  phi = (1 + sqrt(5)) / 2 @{ color: "#000000" }

  p_si = (2 / 3) * cosh((1 / 3) * arccosh(29 / 2)) + 1 / 3 @{ color: "#000000" }

  d_elta = 1 + sqrt(2) @{ color: "#c74440" }

  i = (0, 1) @{ color: "#000000", hidden: true }

  R = (1, 0) @{ color: "#388c46", hidden: true }

  I_B3(Psi_0x, Psi_0xx, Psi_0xxx, Psi_0xxxx, Psi_0xxxxx) =
    Psi_0x + Psi_0xxxxx(-3 * Psi_0x + 3 * Psi_0xx) +
      Psi_0xxxxx ^ 2 * (3 * Psi_0x - 6 * Psi_0xx + 3 * Psi_0xxx) +
      Psi_0xxxxx ^ 3 * (-Psi_0x + 3 * Psi_0xx - 3 * Psi_0xxx + Psi_0xxxx) @{
    color: "#c74440",
  }

  I_M(Psi_0ls, Psi_0x, Psi_0xx) =
    M_V(Psi_0ls) *
      {
        M_S(Psi_0ls) = 1:
        (
            sum Psi_0xax=(1 ... sqrt(M_L(Psi_0ls)))
            (
              Psi_0xx ^ (Psi_0xax - 1) *
                (
                  sum Psi_0xxax=(1 ... sqrt(M_L(Psi_0ls)))
                  (
                    Psi_0ls[(Psi_0xax - 1) * sqrt(M_L(Psi_0ls)) + Psi_0xxax] *
                      Psi_0x[Psi_0xxax]
                  )
                )
            )
          )
      } @{ color: "#c74440" }

  I_L(Psi_0ls, Psi_0x, Psi_0xx) = (1 - Psi_0xx) * Psi_0ls + Psi_0xx * Psi_0x @{
    color: "#000000",
  }

  M_StM(Psi_0ls, Psi_0x) =
    (
      [
        {|Psi_0ls[Psi_0xj1x]| >= 0: Psi_0ls[Psi_0xj1x], 0} for Psi_0xj1x = [
          1
          ...
          Psi_0x * ceil(count(Psi_0ls) / Psi_0x)
        ]
      ]
    ).join(Psi_0x) @{ color: "#c74440" }

  M_StMl(Psi_0ls, Psi_0x) =
    (
      [
        {|Psi_0ls[Psi_0x1x]| >= 0: Psi_0ls[Psi_0x1x], 0} for Psi_0x1x = [
          1
          ...
          Psi_0x * ceil(count(Psi_0ls) / Psi_0x)
        ]
      ]
    ).join(ceil(count(Psi_0ls) / Psi_0x)) @{ color: "#c74440" }

  M_L(Psi_0ls) = count(Psi_0ls) - 1 @{ color: "#000000", hidden: true }

  M_l(Psi_0ls) = M_L(Psi_0ls) / Psi_0ls[count(Psi_0ls)] @{ color: "#388c46" }

  M_h(Psi_0ls) = Psi_0ls[count(Psi_0ls)] @{ color: "#2d70b3" }

  M_V(Psi_0ls) = {M_L(Psi_0ls) = M_l(Psi_0ls) * M_h(Psi_0ls): 1} @{
    color: "#388c46",
  }

  M_S(Psi_0ls) = M_V(Psi_0ls) * {M_l(Psi_0ls) = M_h(Psi_0ls): 1} @{
    color: "#2d70b3",
  }

  M_MtS(Psi_0ls) = [Psi_0ls[Psi_0x12x] for Psi_0x12x = [1 ... M_L(Psi_0ls)]] @{
    color: "#6042a6",
  }

  M_i(Psi_0ls, Psi_01x) =
    [
      M_MtS(Psi_0ls)[M_l(Psi_0ls) * (Psi_01x.y - 1) + Psi_0jx0] for Psi_0jx0 = [
        1
        ...
        M_l(Psi_0ls)
      ]
    ][Psi_01x.x] @{ color: "#2d70b3" }

  M_sum(Psi_0ls, Psi_0xxxx) =
    {
      {M_l(Psi_0ls) = M_l(Psi_0xxxx): 1} - {M_h(Psi_0ls) = M_h(Psi_0xxxx): 1} =
        0:
      M_StM(M_MtS(Psi_0ls) + M_MtS(Psi_0xxxx), M_h(Psi_0ls))
    } @{ color: "#6042a6" }

  M_dif(Psi_0ls, Psi_0xxxx) =
    {
      {M_l(Psi_0ls) = M_l(Psi_0xxxx): 1} - {M_h(Psi_0ls) = M_h(Psi_0xxxx): 1} =
        0:
      M_StM(M_MtS(Psi_0ls) - M_MtS(Psi_0xxxx), M_h(Psi_0ls))
    } @{ color: "#c74440" }

  M_exph(Psi_0ls) =
    (
      [
        {
          ceil(
            (mod(Psi_0435x - 0.1, M_l(Psi_0ls) + 1) + 0.2) / (M_l(Psi_0ls) + 1)
          ) =
            1:
          Psi_0ls[Psi_0435x],
          0
        } for Psi_0435x = [1 ... M_L(Psi_0ls) + M_h(Psi_0ls)]
      ]
    ).join(M_h(Psi_0ls)) @{ color: "#6042a6" }

  M_expl(Psi_0ls) =
    (
      [
        {Psi_03x <= M_L(Psi_0ls): Psi_0ls[Psi_03x], 0} for Psi_03x = [
          1
          ...
          M_L(Psi_0ls) + M_l(Psi_0ls)
        ]
      ]
    ).join(M_h(Psi_0ls) + 1) @{ color: "#388c46" }

  M_T(Psi_0ls) =
    (
      [
        Psi_0ls[M_rel(Psi_042x, M_l(Psi_0ls), M_h(Psi_0ls))] for Psi_042x = [
          1
          ...
          M_L(Psi_0ls)
        ]
      ]
    ).join(M_l(Psi_0ls)) @{ color: "#000000" }

  M_dsprs(Psi_0ls, Psi_0234x, Psi_0434x) =
    {
      Psi_0434x = 1: 1,
      ceil(mod((Psi_0ls - 1 + 1 / 2) / Psi_0234x, Psi_0434x))
    } @{ color: "#388c46" }

  M_rel(Psi_0ls, Psi_0565x, Psi_0535x) =
    M_dsprs(Psi_0ls, Psi_0535x, Psi_0565x) +
      Psi_0565x(M_dsprs(Psi_0ls, 1, Psi_0535x) - 1) @{ color: "#2d70b3" }

  M_v(Psi_0ls) = {M_L(Psi_0ls) = M_h(Psi_0ls): 1, 0} @{ color: "#c74440" }

  M_StV(Psi_0ls) = Psi_0ls.join(count(Psi_0ls)) @{ color: "#2d70b3" }

  M_dpdt(Psi_0ls, Psi_04563x) =
    {
      M_v(Psi_0ls) * M_v(Psi_04563x) * {M_h(Psi_0ls) = M_h(Psi_04563x): 1, 0} =
        1:
      (
          sum Psi_027x=(1 ... M_h(Psi_0ls))
          (Psi_0ls[Psi_027x] * Psi_04563x[Psi_027x])
        )
    } @{ color: "#000000" }

  M_OPtV(Psi_0ls) = [Psi_0ls.x, Psi_0ls.y, 2] @{ color: "#6042a6" }

  M_VtOP(Psi_0ls) = {M_h(Psi_0ls) = 2: (Psi_0ls[1], Psi_0ls[2])} @{
    color: "#000000",
  }

  M_loop(Psi_0ls, Psi_0x) =
    mod(
      M_dsprs(Psi_0ls, Psi_0x, Psi_0x) + M_dsprs(Psi_0ls, 1, Psi_0x) - 2,
      Psi_0x
    ) +
      1 @{ color: "#6042a6" }

  M_det2(Psi_0ls) =
    {
      M_S(Psi_0ls) * M_l(Psi_0ls) = 2:
      Psi_0ls[1] * Psi_0ls[4] - Psi_0ls[2] * Psi_0ls[3]
    } @{ color: "#388c46" }

  M_sar(Psi_0ls) =
    {
      M_S(Psi_0ls) = 1:
      (
          sum Psi_045x=(1 ... M_h(Psi_0ls))
          (
            product Psi_0146x=(1 ... M_h(Psi_0ls))
            (
              M_r(Psi_0ls, Psi_0146x)[
                M_loop(3 * (Psi_045x - 1) + Psi_0146x, M_h(Psi_0ls))
              ]
            )
          )
        ) -
          (
            sum Psi_045x=(1 ... M_h(Psi_0ls))
            (
              product Psi_0146x=(1 ... M_h(Psi_0ls))
              (
                M_r(Psi_0ls, Psi_0146x)[
                  M_loop(
                    -(3 * (Psi_045x - 1) + Psi_0146x) + 1 + M_h(Psi_0ls),
                    M_h(Psi_0ls)
                  )
                ]
              )
            )
          )
    } @{ color: "#c74440" }

  M_c(Psi_0ls, Psi_046x) =
    [M_i(Psi_0ls, (Psi_046x, Psi_057x)) for Psi_057x = [1 ... M_h(Psi_0ls)]] @{
    color: "#000000",
  }

  M_r(Psi_0ls, Psi_046x) =
    [
      M_i(Psi_0ls, (Psi_0517x, Psi_046x)) for Psi_0517x = [1 ... M_l(Psi_0ls)]
    ] @{ color: "#6042a6" }

  M_pdt(Psi_0ls, Psi_0x2) =
    {
      M_l(Psi_0ls) = M_h(Psi_0x2):
      (
          [
            M_dpdt(
              M_StV(M_r(Psi_0ls, M_dsprs(Psi_0x1, M_l(Psi_0x2), M_h(Psi_0ls)))),
              M_StV(M_c(Psi_0x2, M_dsprs(Psi_0x1, 1, M_l(Psi_0x2))))
            ) for Psi_0x1 = [1 ... M_h(Psi_0ls) * M_l(Psi_0x2)]
          ]
        ).join(M_h(Psi_0ls))
    } @{ color: "#000000" }

  M_cpdt(Psi_0ls, Psi_04563x) =
    {
      M_v(Psi_0ls) * M_v(Psi_04563x) * {M_h(Psi_0ls) = M_h(Psi_04563x): 1, 0} *
        {M_h(Psi_0ls) = 3: 1, 0} =
        1:
      (
          M_pdt(
            M_StM(
              [
                0,
                -Psi_0ls[3],
                Psi_0ls[2],
                Psi_0ls[3],
                0,
                -Psi_0ls[1],
                -Psi_0ls[2],
                Psi_0ls[1],
                0
              ],
              3
            ),
            Psi_04563x
          )
        ).join(3)
    } @{ color: "#c74440" }

  M_wpdt(Psi_0ls, Psi_04563x) =
    {
      M_v(Psi_0ls) * M_v(Psi_04563x) * {M_h(Psi_0ls) = M_h(Psi_04563x): 1, 0} =
        1:
      M_dif(M_pdt(Psi_0ls, M_T(Psi_04563x)), M_pdt(Psi_04563x, M_T(Psi_0ls)))
    } @{ color: "#2d70b3" }

  M_tpdt(Psi_0ls, Psi_04563x) =
    {
      M_v(Psi_0ls) * M_v(Psi_04563x) * {M_h(Psi_0ls) = M_h(Psi_04563x): 1, 0} =
        1:
      M_dif(M_pdt(Psi_04563x, M_T(Psi_0ls)), M_pdt(Psi_0ls, M_T(Psi_04563x)))
    } @{ color: "#388c46" }

  M_Vm(Psi_0ls) =
    {
      M_v(Psi_0ls) = 1:
      sqrt(sum Psi_0x21=(1 ... M_h(Psi_0ls)) (Psi_0ls[Psi_0x21] ^ 2))
    } @{ color: "#6042a6" }

  I_gB(Psi_0ls, Psi_04x7, Psi_02x2) =
    (
      sum Psi_01x1=(0 ... Psi_0ls)
      (
        nCr(Psi_0ls, Psi_01x1) * (1 - Psi_02x2) ^ (Psi_0ls - Psi_01x1) *
          Psi_02x2 ^ Psi_01x1 *
          Psi_04x7[Psi_01x1 + 1]
      )
    ) @{ color: "#2d70b3" }

  R_sinrp(Psi_0ls, Psi_01x6) =
    {
      mod(floor(Psi_0ls / pi), 2) = 1:
      (sin(pi * (Psi_0ls / pi)) + 1) ^ Psi_01x6,
      -((sin(-pi * (Psi_0ls / pi)) + 1) ^ Psi_01x6) + 2
    } -
      1 @{ color: "#388c46" }

  R_cosrp(Psi_0ls, Psi_01x6) = R_sinrp(Psi_0ls + pi / 2, Psi_01x6) @{
    color: "#000000",
  }

  R_tanrp(Psi_0ls, Psi_01x6) =
    R_sinrp(Psi_0ls, Psi_01x6) / R_cosrp(Psi_0ls, Psi_01x6) @{
    color: "#000000",
  }

  R_cotrp(Psi_0ls, Psi_01x6) =
    R_cosrp(Psi_0ls, Psi_01x6) / R_sinrp(Psi_0ls, Psi_01x6) @{
    color: "#6042a6",
  }

  R_secrp(Psi_0ls, Psi_01x6) = 1 / R_cosrp(Psi_0ls, Psi_01x6) @{
    color: "#2d70b3",
  }

  R_cscrp(Psi_0ls, Psi_01x6) = 1 / R_sinrp(Psi_0ls, Psi_01x6) @{
    color: "#000000",
  }

  R_sin2rp(Psi_0ls, Psi_01x6) =
    {
      mod(floor(Psi_0ls / pi), 2) = 1:
      |2 * mod(-(Psi_0ls / pi), 1) - 1| ^ Psi_01x6 - 1,
      -(|2 * mod(-(Psi_0ls / pi), 1) - 1| ^ Psi_01x6) + 1
    } @{ color: "#000000" }

  R_cos2rp(Psi_0ls, Psi_01x6) = R_sin2rp(Psi_0ls + pi / 2, Psi_01x6) @{
    color: "#000000",
  }

  R_tan2rp(Psi_0ls, Psi_01x6) =
    R_sin2rp(Psi_0ls, Psi_01x6) / R_cos2rp(Psi_0ls, Psi_01x6) @{
    color: "#000000",
  }

  R_cot2rp(Psi_0ls, Psi_01x6) =
    R_cos2rp(Psi_0ls, Psi_01x6) / R_sin2rp(Psi_0ls, Psi_01x6) @{
    color: "#000000",
  }

  R_sec2rp(Psi_0ls, Psi_01x6) = 1 / R_cos2rp(Psi_0ls, Psi_01x6) @{
    color: "#000000",
  }

  R_csc2rp(Psi_0ls, Psi_01x6) = 1 / R_sin2rp(Psi_0ls, Psi_01x6) @{
    color: "#000000",
  }

  I_pfs(Psi_0ls, Psi_xz) =
    (
      sum Psi_0xz2=(1 ... count(Psi_0ls))
      (Psi_0ls[Psi_0xz2] * C_exp((0, -tau * Psi_0xz2 * Psi_xz)))
    ) @{ color: "#c74440" }

  I_pfc(Psi_0ls, Psi_xz) =
    [
      Psi_0ls[Psi_0xy2] * C_exp((0, -tau * Psi_0xy2 * Psi_xz)) for Psi_0xy2 = [
        1
        ...
        count(Psi_0ls)
      ]
    ] @{ color: "#6042a6" }

  I_fs(Psi_0ls, Psi_0x, Psi_xz) =
    (
      sum Psi_0xo2=(1 ... count(Psi_0ls))
      (Psi_0ls[Psi_0xo2] * C_exp((0, -tau(Psi_0xo2 - Psi_0x) * Psi_xz)))
    ) @{ color: "#c74440" }

  I_fc(Psi_0ls, Psi_0x, Psi_xz) =
    [
      Psi_0ls[Psi_0xd2] *
        C_exp((0, -tau(Psi_0xd2 - Psi_0x) * Psi_xz)) for Psi_0xd2 = [
        1
        ...
        count(Psi_0ls)
      ]
    ] @{ color: "#000000" }

  M_omt(Psi_0ls, Psi_0x) =
    ceil(Psi_0ls - 0.5) + {Psi_0ls + 0.5 - Psi_0x >= 0: 1, 0} @{
    color: "#c74440",
  }

  M_rr(Psi_0ls, Psi_0x) =
    (
      [
        Psi_0ls[
          M_skiph(Psi_010x0, M_h(Psi_0ls), M_l(Psi_0ls), Psi_0x)
        ] for Psi_010x0 = [1 ... M_L(Psi_0ls) - M_l(Psi_0ls)]
      ]
    ).join(M_h(Psi_0ls) - 1) @{ color: "#388c46" }

  M_rc(Psi_0ls, Psi_0x) =
    (
      [
        Psi_0ls[
          M_skipl(Psi_09x01, M_h(Psi_0ls), M_l(Psi_0ls), Psi_0x)
        ] for Psi_09x01 = [1 ... M_L(Psi_0ls) - M_h(Psi_0ls)]
      ]
    ).join(M_h(Psi_0ls)) @{ color: "#388c46" }

  M_skiph(Psi_0ls, Psi_0x, Psi_0xx, Psi_0xxx) =
    M_dsprs(Psi_0ls, 1, Psi_0xx) +
      Psi_0xx(M_omt(M_dsprs(Psi_0ls, Psi_0xx, Psi_0x - 1), Psi_0xxx) - 1) @{
    color: "#6042a6",
  }

  M_skipl(Psi_0ls, Psi_0x, Psi_0xx, Psi_0xxx) =
    M_omt(M_dsprs(Psi_0ls, 1, Psi_0xx - 1), Psi_0xxx) +
      Psi_0xx(M_dsprs(Psi_0ls, Psi_0xx - 1, Psi_0x) - 1) @{ color: "#c74440" }

  M_mnr(Psi_0ls, Psi_0x) = M_rc(M_rr(Psi_0ls, Psi_0x.x), Psi_0x.y) @{
    color: "#6042a6",
  }

  M_cft(Psi_0ls, Psi_01x) =
    ((-1) ^ (Psi_01x.x + Psi_01x.y) * M_MtS(M_mnr(Psi_0ls, Psi_01x))).join(
      M_h(M_mnr(Psi_0ls, Psi_01x))
    ) @{ color: "#000000" }

  M_det4(Psi_0ls) =
    {
      M_S(Psi_0ls) = 1:
      {
          M_h(Psi_0ls) = 4:
          (
              sum Psi_02x3=(1 ... M_l(Psi_0ls))
              (
                M_i(Psi_0ls, (Psi_02x3, 1)) *
                  M_det3(M_cft(Psi_0ls, (Psi_02x3, 1)))
              )
            )
        }
    } @{ color: "#c74440" }

  C_acosh(Psi_0ls) = C_plg(Psi_0ls + C_pow(C_pow(Psi_0ls, 2 * R) - R, R / 2)) @{
    color: "#6042a6",
  }

  C_atanh(Psi_0ls) = C_qnt(C_plg(C_qnt(R + Psi_0ls, R - Psi_0ls)), 2 * R) @{
    color: "#6042a6",
  }

  C_acoth(Psi_0ls) = C_atanh(C_qnt(R, Psi_0ls)) @{ color: "#c74440" }

  C_asech(Psi_0ls) = C_acosh(C_pow(Psi_0ls, -R)) @{ color: "#6042a6" }

  C_acsch(Psi_0ls) = C_asinh(C_pow(Psi_0ls, -R)) @{ color: "#000000" }

  C_atan(Psi_0ls) = C_pdt(i, C_atanh(C_pdt(Psi_0ls, -i))) @{ color: "#c74440" }

  C_acot(Psi_0ls) = (pi * R) / 2 - C_atan(Psi_0ls) @{ color: "#388c46" }

  C_asec(Psi_0ls) = C_acos(C_pow(Psi_0ls, -R)) @{ color: "#000000" }

  C_acsc(Psi_0ls) = C_asin(C_pow(Psi_0ls, -R)) @{ color: "#c74440" }

  M_det5(Psi_0ls) =
    {
      M_S(Psi_0ls) = 1:
      {
          M_h(Psi_0ls) = 5:
          (
              sum Psi_021x3=(1 ... M_l(Psi_0ls))
              (
                M_i(Psi_0ls, (Psi_021x3, 1)) *
                  M_det4(M_cft(Psi_0ls, (Psi_021x3, 1)))
              )
            )
        }
    } @{ color: "#c74440" }

  M_det6(Psi_0ls) =
    {
      M_S(Psi_0ls) = 1:
      {
          M_h(Psi_0ls) = 6:
          (
              sum Psi_0211x3=(1 ... M_l(Psi_0ls))
              (
                M_i(Psi_0ls, (Psi_0211x3, 1)) *
                  M_det5(M_cft(Psi_0ls, (Psi_0211x3, 1)))
              )
            )
        }
    } @{ color: "#c74440" }

  M_det7(Psi_0ls) =
    {
      M_S(Psi_0ls) = 1:
      {
          M_h(Psi_0ls) = 7:
          (
              sum Psi_02111x3=(1 ... M_l(Psi_0ls))
              (
                M_i(Psi_0ls, (Psi_02111x3, 1)) *
                  M_det6(M_cft(Psi_0ls, (Psi_02111x3, 1)))
              )
            )
        }
    } @{ color: "#2d70b3" }

  M_det8(Psi_0ls) =
    {
      M_S(Psi_0ls) = 1:
      {
          M_h(Psi_0ls) = 8:
          (
              sum Psi_02121x3=(1 ... M_l(Psi_0ls))
              (
                M_i(Psi_0ls, (Psi_02121x3, 1)) *
                  M_det7(M_cft(Psi_0ls, (Psi_02121x3, 1)))
              )
            )
        }
    } @{ color: "#6042a6" }

  M_det9(Psi_0ls) =
    {
      M_S(Psi_0ls) = 1:
      {
          M_h(Psi_0ls) = 9:
          (
              sum Psi_02131x3=(1 ... M_l(Psi_0ls))
              (
                M_i(Psi_0ls, (Psi_02131x3, 1)) *
                  M_det8(M_cft(Psi_0ls, (Psi_02131x3, 1)))
              )
            )
        }
    } @{ color: "#000000" }

  M_det10(Psi_0ls) =
    {
      M_S(Psi_0ls) = 1:
      {
          M_h(Psi_0ls) = 10:
          (
              sum Psi_02231x3=(1 ... M_l(Psi_0ls))
              (
                M_i(Psi_0ls, (Psi_02231x3, 1)) *
                  M_det9(M_cft(Psi_0ls, (Psi_02231x3, 1)))
              )
            )
        }
    } @{ color: "#c74440" }

  M_W2(Psi_0ls) =
    M_StM([cos(Psi_0ls), -sin(Psi_0ls), sin(Psi_0ls), cos(Psi_0ls)], 2) @{
    color: "#c74440",
    hidden: true,
  }

  M_W3(Psi_0ls, Psi_0x, Psi_0xx) =
    M_pdt3(
      M_pdt3(
        M_StM(
          [
            cos(Psi_0xx),
            sin(Psi_0xx),
            0,
            -sin(Psi_0xx),
            cos(Psi_0xx),
            0,
            0,
            0,
            1
          ],
          3
        ),
        M_StM(
          [1, 0, 0, 0, cos(Psi_0x), sin(Psi_0x), 0, -sin(Psi_0x), cos(Psi_0x)],
          3
        )
      ),
      M_StM(
        [
          cos(Psi_0ls),
          sin(Psi_0ls),
          0,
          -sin(Psi_0ls),
          cos(Psi_0ls),
          0,
          0,
          0,
          1
        ],
        3
      )
    ) @{ color: "#2d70b3" }

  R_bta(Psi_0ls, Psi_0x) =
    (R_gma(Psi_0ls) * R_gma(Psi_0x)) / R_gma(Psi_0ls + Psi_0x) @{
    color: "#c74440",
  }

  P_cx(Psi_0ls, Psi_0x, Psi_0xx) = Psi_0ls(sin(Psi_0x) * sin(Psi_0xx)) @{
    color: "#2d70b3",
  }

  P_cy(Psi_0ls, Psi_0x, Psi_0xx) = Psi_0ls(sin(Psi_0x) * cos(Psi_0xx)) @{
    color: "#388c46",
  }

  P_cz(Psi_0ls, Psi_0x, Psi_0xx) = Psi_0ls * cos(Psi_0x) @{ color: "#6042a6" }

  P_Cx(
    Psi_0xmn,
    Psi_0ymn,
    Psi_0zmn,
    Psi_0xgn,
    Psi_0ygn,
    Psi_0zgn,
    Psi_0rgn,
    Psi_0phi00,
    Psi_0theta,
    Psi_0zoom
  ) =
    (
      (
        (Psi_0xmn - Psi_0xgn) * cos(Psi_0theta) -
          (Psi_0ymn - Psi_0ygn) * sin(Psi_0theta)
      ) /
        P_Cz(
          Psi_0xmn,
          Psi_0ymn,
          Psi_0zmn,
          Psi_0xgn,
          Psi_0ygn,
          Psi_0zgn,
          Psi_0rgn,
          Psi_0phi00,
          Psi_0theta,
          Psi_0zoom
        )
    ) *
      Psi_0zoom @{ color: "#c74440" }

  P_Cy(
    Psi_0xmn,
    Psi_0ymn,
    Psi_0zmn,
    Psi_0xgn,
    Psi_0ygn,
    Psi_0zgn,
    Psi_0rgn,
    Psi_0phi00,
    Psi_0theta,
    Psi_0zoom
  ) =
    (
      (
        (Psi_0xmn - Psi_0xgn) * sin(Psi_0theta) * cos(Psi_0phi00) +
          (Psi_0ymn - Psi_0ygn) * cos(Psi_0theta) * cos(Psi_0phi00) -
          (Psi_0zmn - Psi_0zgn) * sin(Psi_0phi00)
      ) /
        P_Cz(
          Psi_0xmn,
          Psi_0ymn,
          Psi_0zmn,
          Psi_0xgn,
          Psi_0ygn,
          Psi_0zgn,
          Psi_0rgn,
          Psi_0phi00,
          Psi_0theta,
          Psi_0zoom
        )
    ) *
      Psi_0zoom @{ color: "#2d70b3" }

  P_Cz(
    Psi_0xmn,
    Psi_0ymn,
    Psi_0zmn,
    Psi_0xgn,
    Psi_0ygn,
    Psi_0zgn,
    Psi_0rgn,
    Psi_0phi00,
    Psi_0theta,
    Psi_0zoom
  ) =
    -(
      (Psi_0xmn - P_cx(Psi_0rgn, Psi_0phi00, Psi_0theta) - Psi_0xgn) *
        sin(Psi_0theta) *
        sin(Psi_0phi00) +
        (Psi_0ymn - P_cy(Psi_0rgn, Psi_0phi00, Psi_0theta) - Psi_0ygn) *
          cos(Psi_0theta) *
          sin(Psi_0phi00) +
        (Psi_0zmn - P_cz(Psi_0rgn, Psi_0phi00, Psi_0theta) - Psi_0zgn) *
          cos(Psi_0phi00)
    ) @{ color: "#388c46" }

  P_proj(Psi_0pos0, Psi_0cpos0, Psi_0polar0, Psi_0rgn, Psi_0zoom) =
    C_pdt(
      (
        P_Cx(
          Psi_0pos0[1],
          Psi_0pos0[2],
          Psi_0pos0[3],
          Psi_0cpos0[1],
          Psi_0cpos0[2],
          Psi_0cpos0[3],
          Psi_0polar0[3],
          -Psi_0polar0[1],
          -Psi_0polar0[2] - pi / 2,
          Psi_0zoom
        ),
        P_Cy(
          Psi_0pos0[1],
          Psi_0pos0[2],
          Psi_0pos0[3],
          Psi_0cpos0[1],
          Psi_0cpos0[2],
          Psi_0cpos0[3],
          Psi_0polar0[3],
          -Psi_0polar0[1],
          -Psi_0polar0[2] - pi / 2,
          Psi_0zoom
        )
      ),
      C_exp(-Psi_0rgn * i)
    ) *
      {
        P_Cz(
          Psi_0pos0[1],
          Psi_0pos0[2],
          Psi_0pos0[3],
          Psi_0cpos0[1],
          Psi_0cpos0[2],
          Psi_0cpos0[3],
          Psi_0polar0[3],
          -Psi_0polar0[1],
          -Psi_0polar0[2] - pi / 2,
          Psi_0zoom
        ) >
          0:
        1
      } @{ color: "#000000" }

  Q_pdt(Psi_0ls, Psi_0x) =
    [
      Psi_0ls[1] * Psi_0x[1] - Psi_0ls[2] * Psi_0x[2] - Psi_0ls[3] * Psi_0x[3] -
        Psi_0ls[4] * Psi_0x[4],
      Psi_0ls[1] * Psi_0x[2] + Psi_0ls[2] * Psi_0x[1] + Psi_0ls[3] * Psi_0x[4] -
        Psi_0ls[4] * Psi_0x[3],
      Psi_0ls[1] * Psi_0x[3] + Psi_0ls[3] * Psi_0x[1] + Psi_0ls[4] * Psi_0x[2] -
        Psi_0ls[2] * Psi_0x[4],
      Psi_0ls[1] * Psi_0x[4] + Psi_0ls[4] * Psi_0x[1] + Psi_0ls[2] * Psi_0x[3] -
        Psi_0ls[3] * Psi_0x[2]
    ] @{ color: "#c74440" }

  P_rotq(Psi_0ls, Psi_0x, Psi_0xx) =
    [
      Q_pdt(
        Q_pdt(
          [cos(Psi_0xx / 2), 0, 0, 0] +
            sin(Psi_0xx / 2) * [0, Psi_0x[1], Psi_0x[2], Psi_0x[3]],
          [0, Psi_0ls[1], Psi_0ls[2], Psi_0ls[3]]
        ),
        [cos(-(Psi_0xx / 2)), 0, 0, 0] +
          sin(-(Psi_0xx / 2)) * [0, Psi_0x[1], Psi_0x[2], Psi_0x[3]]
      )[2],
      Q_pdt(
        Q_pdt(
          [cos(Psi_0xx / 2), 0, 0, 0] +
            sin(Psi_0xx / 2) * [0, Psi_0x[1], Psi_0x[2], Psi_0x[3]],
          [0, Psi_0ls[1], Psi_0ls[2], Psi_0ls[3]]
        ),
        [cos(-(Psi_0xx / 2)), 0, 0, 0] +
          sin(-(Psi_0xx / 2)) * [0, Psi_0x[1], Psi_0x[2], Psi_0x[3]]
      )[3],
      Q_pdt(
        Q_pdt(
          [cos(Psi_0xx / 2), 0, 0, 0] +
            sin(Psi_0xx / 2) * [0, Psi_0x[1], Psi_0x[2], Psi_0x[3]],
          [0, Psi_0ls[1], Psi_0ls[2], Psi_0ls[3]]
        ),
        [cos(-(Psi_0xx / 2)), 0, 0, 0] +
          sin(-(Psi_0xx / 2)) * [0, Psi_0x[1], Psi_0x[2], Psi_0x[3]]
      )[4]
    ] @{ color: "#388c46" }

  E_bexp(Psi_0ls, Psi_0x, Psi_0xx) =
    [
      nCr(Psi_0xx, Psi_0hj2) * Psi_0ls ^ (Psi_0xx - Psi_0hj2) *
        Psi_0x ^ Psi_0hj2 for Psi_0hj2 = [0 ... Psi_0xx]
    ] @{ color: "#c74440" }

  E_cbexp(Psi_0ls, Psi_0x, Psi_0xx) =
    [
      nCr(Psi_0xx, Psi_0h1j2) *
        C_pdt(
          C_pow(Psi_0ls, Psi_0xx - Psi_0h1j2) * C_pow(Psi_0x, Psi_0h1j2)
        ) for Psi_0h1j2 = [0 ... Psi_0xx]
    ] @{ color: "#6042a6" }

  I_cdstm(Psi_0ls) =
    M_StM(
      [
        0,
        1,
        0,
        0,
        -Psi_0ls,
        0,
        Psi_0ls,
        0,
        2 * Psi_0ls,
        Psi_0ls - 3,
        3 - 2 * Psi_0ls,
        -Psi_0ls,
        -Psi_0ls,
        2 - Psi_0ls,
        Psi_0ls - 2,
        Psi_0ls
      ],
      4
    ) @{ color: "#388c46", hidden: true }

  I_pm(Psi_0ls) =
    (([2 * Psi_0ls[1] - Psi_0ls[2]]).join(Psi_0ls)).join(
      2 * Psi_0ls[count(Psi_0ls)] - Psi_0ls[count(Psi_0ls) - 1]
    ) @{ color: "#2d70b3" }

  I_cd(Psi_0ls, Psi_0x, Psi_0xx) =
    [
      {
        Psi_0xx < Psi_000v / (count(Psi_0ls) - 1):
        I_M(
            I_cdstm(Psi_0x),
            [
              I_pm(Psi_0ls)[Psi_00v + Psi_000v - 1] for Psi_00v = [
                1
                ...
                count(Psi_0ls)
              ]
            ],
            (count(Psi_0ls) - 1) * mod(Psi_0xx, 1 / (count(Psi_0ls) - 1))
          )
      } for Psi_000v = [1 ... count(Psi_0ls)]
    ][ceil((count(Psi_0ls) - 1) * Psi_0xx)] @{ color: "#c74440" }

  I_S(Psi_0ls) = 3 * Psi_0ls ^ 2 - 2 * Psi_0ls ^ 3 @{
    color: "#000000",
    hidden: true,
  }

  I_iS(Psi_0ls) = 1 / 2 - sin(arcsin(1 - 2 * Psi_0ls) / 3) @{
    color: "#c74440",
    hidden: true,
  }

  I_nM(Psi_0ls, Psi_0x, Psi_0xx) =
    {M_l(Psi_0ls) = count(Psi_0x): 1} *
      (
        sum Psi_080j=(1 ... M_l(Psi_0ls))
        (
          sum Psi_030j=(1 ... M_h(Psi_0ls))
          (
            Psi_0xx ^ (Psi_030j - 1) * M_c(Psi_0ls, Psi_080j)[Psi_030j] *
              Psi_0x[Psi_030j]
          )
        )
      ) @{ color: "#c74440" }

  I_nM3(Psi_0ls, Psi_0x, Psi_0xx) =
    {M_l(Psi_0ls) = M_h(Psi_0x): 1} *
      (
        sum Psi_081j=(1 ... M_l(Psi_0ls))
        (
          sum Psi_031j=(1 ... M_h(Psi_0ls))
          (
            Psi_0xx ^ (Psi_031j - 1) * M_c(Psi_0ls, Psi_081j)[Psi_031j] *
              M_r(Psi_0x, Psi_081j)
          )
        )
      ) @{ color: "#c74440" }

  I_kf(Psi_0ls, Psi_0x, Psi_0xx, Psi_0xxx) =
    (Psi_0xxx - Psi_0xx[Psi_0ls]) /
      (Psi_0xx[Psi_0ls + Psi_0x] - Psi_0xx[Psi_0ls]) @{ color: "#6042a6" }

  I_kg(Psi_0ls, Psi_0x, Psi_0xx, Psi_0xxx) =
    1 - I_kf(Psi_0ls, Psi_0x, Psi_0xx, Psi_0xxx) @{ color: "#000000" }

  I_N0(Psi_0ls, Psi_0x, Psi_0xx) =
    {Psi_0x[Psi_0ls] < Psi_0xx <= Psi_0x[Psi_0ls + 1]: 1, 0} @{
    color: "#c74440",
  }

  I_N1(Psi_0ls, Psi_0x, Psi_0xx) =
    I_kf(Psi_0ls, 1, Psi_0x, Psi_0xx) * I_N0(Psi_0ls, Psi_0x, Psi_0xx) +
      I_kg(Psi_0ls + 1, 1, Psi_0x, Psi_0xx) *
        I_N0(Psi_0ls + 1, Psi_0x, Psi_0xx) @{ color: "#c74440" }

  I_N2(Psi_0ls, Psi_0x, Psi_0xx) =
    I_kf(Psi_0ls, 2, Psi_0x, Psi_0xx) * I_N1(Psi_0ls, Psi_0x, Psi_0xx) +
      I_kg(Psi_0ls + 1, 2, Psi_0x, Psi_0xx) *
        I_N1(Psi_0ls + 1, Psi_0x, Psi_0xx) @{ color: "#2d70b3" }

  I_NURBS(Psi_0ls, Psi_0x, Psi_0xx, Psi_0xxx) =
    (
      sum Psi_00g=(1 ... count(Psi_0ls))
      (
        (
          (
            I_N2(Psi_00g, I_normk(Psi_0x), Psi_0xxx) *
              {Psi_00g <= count(Psi_0xx): Psi_0xx[Psi_00g], 1}
          ) /
            (
              sum Psi_01g=(1 ... count(Psi_0ls))
              (I_N2(Psi_01g, I_normk(Psi_0x), Psi_0xxx) * Psi_0xx[Psi_01g])
            )
        ) *
          Psi_0ls[Psi_00g]
      )
    ) @{ color: "#c74440" }

  I_normk(Psi_0ls) =
    (([min(Psi_0ls) - 0.001]).join(Psi_0ls)).join(max(Psi_0ls) + 0.0001) @{
    color: "#c74440",
    hidden: true,
  }

  I_mL(Psi_0ls, Psi_0x) =
    [
      I_L(
        Psi_0ls[Psi_0kk],
        Psi_0ls[Psi_0kk + 1],
        mod((count(Psi_0ls) - 1) * Psi_0x, 1)
      ) for Psi_0kk = [1 ... count(Psi_0ls) - 1]
    ][ceil((count(Psi_0ls) - 1) * Psi_0x)] @{ color: "#c74440" }

  R_flat(Psi_0ls, Psi_0x) = arctan(sin(Psi_0ls) / Psi_0x) / arccot(|Psi_0x|) @{
    color: "#c74440",
  }

  C_flat(Psi_0ls, Psi_0x) =
    C_qnt(C_atan(C_qnt(C_sin(Psi_0ls), Psi_0x)), C_atan(C_abs(Psi_0x))) @{
    color: "#c74440",
  }

  I_rsBp(Psi_0ls, Psi_0x, Psi_0xxx, Psi_0xx) =
    [
      I_rsB(Psi_0ls, Psi_0x, Psi_0xxx, Psi_01p9) for Psi_01p9 = [
        0
        ...
        Psi_0xx - 1
      ] /
        (Psi_0xx - 1)
    ] @{ color: "#2d70b3" }

  I_sBp(Psi_0ls, Psi_0x, Psi_0xx) =
    [
      I_sB(Psi_0ls, Psi_0x, Psi_01pk9) for Psi_01pk9 = [0 ... Psi_0xx - 1] /
        (Psi_0xx - 1)
    ] @{ color: "#6042a6" }

  I_3BcV(Psi_0ls, Psi_0x) =
    [
      I_mL(Psi_0ls[3 * Psi_00p ... 3 * Psi_00p + 2], Psi_0x) for Psi_00p = [
        0
        ...
        count(Psi_0ls) / 3
      ]
    ] @{ color: "#000000" }

  I_bb(Psi_0ls, Psi_0x, Psi_0xx) =
    nCr(Psi_0ls, Psi_0x) * (1 - Psi_0xx) ^ (Psi_0ls - Psi_0x) *
      Psi_0xx ^ Psi_0x @{ color: "#c74440" }

  I_rB(Psi_0ls, Psi_0x, Psi_0xx, Psi_0xxx) =
    (
      sum Psi_0fw3=(0 ... Psi_0ls)
      (
        I_bb(Psi_0ls, Psi_0fw3, Psi_0xxx) * Psi_0x[Psi_0fw3 + 1] *
          Psi_0xx[Psi_0fw3 + 1]
      )
    ) /
      (
        sum Psi_0fw3=(0 ... Psi_0ls)
        (I_bb(Psi_0ls, Psi_0fw3, Psi_0xxx) * Psi_0xx[Psi_0fw3 + 1])
      ) @{ color: "#2d70b3" }

  M_vt2(Psi_0ls, Psi_0x) =
    M_StV(
      [
        Psi_0ls[1] * Psi_0x[1] + Psi_0ls[2] * Psi_0x[2],
        Psi_0ls[1] * Psi_0x[3] + Psi_0ls[2] * Psi_0x[4]
      ]
    ) @{ color: "#c74440" }

  M_vt3(Psi_0ls, Psi_0x) =
    M_StV(
      [
        Psi_0ls[1] * Psi_0x[1] + Psi_0ls[2] * Psi_0x[2] +
          Psi_0ls[3] * Psi_0x[3],
        Psi_0ls[1] * Psi_0x[4] + Psi_0ls[2] * Psi_0x[5] +
          Psi_0ls[3] * Psi_0x[6],
        Psi_0ls[1] * Psi_0x[7] + Psi_0ls[2] * Psi_0x[8] + Psi_0ls[3] * Psi_0x[9]
      ]
    ) @{ color: "#388c46" }

  M_pdt2(Psi_0ls, Psi_0x) =
    M_StM(
      [
        Psi_0ls[1] * Psi_0x[1] + Psi_0ls[2] * Psi_0x[3],
        Psi_0ls[1] * Psi_0x[2] + Psi_0ls[2] * Psi_0x[4],
        Psi_0ls[3] * Psi_0x[1] + Psi_0ls[4] * Psi_0x[3],
        Psi_0ls[3] * Psi_0x[2] + Psi_0ls[2] * Psi_0x[4]
      ],
      2
    ) @{ color: "#000000" }

  M_pdt3(Psi_0ls, Psi_0x) =
    M_StM(
      [
        Psi_0ls[1] * Psi_0x[1] + Psi_0ls[2] * Psi_0x[4] +
          Psi_0ls[3] * Psi_0x[7],
        Psi_0ls[1] * Psi_0x[2] + Psi_0ls[2] * Psi_0x[5] +
          Psi_0ls[3] * Psi_0x[8],
        Psi_0ls[1] * Psi_0x[3] + Psi_0ls[2] * Psi_0x[6] +
          Psi_0ls[3] * Psi_0x[9],
        Psi_0ls[4] * Psi_0x[1] + Psi_0ls[5] * Psi_0x[4] +
          Psi_0ls[6] * Psi_0x[7],
        Psi_0ls[4] * Psi_0x[2] + Psi_0ls[5] * Psi_0x[5] +
          Psi_0ls[6] * Psi_0x[8],
        Psi_0ls[4] * Psi_0x[3] + Psi_0ls[5] * Psi_0x[6] +
          Psi_0ls[6] * Psi_0x[9],
        Psi_0ls[7] * Psi_0x[1] + Psi_0ls[8] * Psi_0x[4] +
          Psi_0ls[9] * Psi_0x[7],
        Psi_0ls[7] * Psi_0x[2] + Psi_0ls[8] * Psi_0x[5] +
          Psi_0ls[9] * Psi_0x[8],
        Psi_0ls[7] * Psi_0x[3] + Psi_0ls[8] * Psi_0x[6] + Psi_0ls[9] * Psi_0x[9]
      ],
      3
    ) @{ color: "#c74440" }

  P_pc(Psi_0ls) = Psi_0ls.x * C_exp(Psi_0ls.y * i) @{ color: "#c74440" }

  P_cp(Psi_0ls) = (C_abs(Psi_0ls), C_arg(Psi_0ls)) @{ color: "#388c46" }

  P_r1Sp(Psi_0ls) = (cot(Psi_0ls[1] / 2), Psi_0ls[2]) @{ color: "#6042a6" }

  P_pS(Psi_0ls) = [2 * arctan(1 / Psi_0ls.x), Psi_0ls.y, 1] @{
    color: "#000000",
  }

  P_SC(Psi_0ls) =
    [
      Psi_0ls[3] * sin(Psi_0ls[1]) * cos(Psi_0ls[2]),
      Psi_0ls[3] * sin(Psi_0ls[1]) * sin(Psi_0ls[2]),
      Psi_0ls[3] * cos(Psi_0ls[1])
    ] @{ color: "#c74440" }

  P_CS(Psi_0ls) =
    [
      arccos(
        Psi_0ls[3] / sqrt(Psi_0ls[1] ^ 2 + Psi_0ls[2] ^ 2 + Psi_0ls[3] ^ 2)
      ),
      sign(Psi_0ls[2]) *
        arccos(Psi_0ls[1] / sqrt(Psi_0ls[1] ^ 2 + Psi_0ls[2] ^ 2)),
      sqrt(Psi_0ls[1] ^ 2 + Psi_0ls[2] ^ 2 + Psi_0ls[3] ^ 2)
    ] @{ color: "#2d70b3" }

  I_rsB(Psi_0x, Psi_0ls, Psi_0xxx, Psi_0xx) =
    {
      Psi_0xx = 1: Psi_0ls[count(Psi_0ls)],

[
          I_rB(
            Psi_0x,
            Psi_0ls[Psi_0x * Psi_0jgs + 1 ... Psi_0x * Psi_0jgs + Psi_0x + 1],
            Psi_0xxx[
              (Psi_0x + 1) * Psi_0jgs + 1
              ...
              (Psi_0x + 1) * (Psi_0jgs + 1)
            ],
            mod(((count(Psi_0ls) - 1) / Psi_0x) * Psi_0xx, 1)
          ) for Psi_0jgs = [0 ... (count(Psi_0ls) - 1) / Psi_0x - 1]
        ][floor(Psi_0xx(count(Psi_0ls) - 1) / Psi_0x) + 1]
    } @{ color: "#c74440" }

  I_sB(Psi_0x, Psi_0ls, Psi_0xx) =
    {
      Psi_0xx = 1: Psi_0ls[count(Psi_0ls)],

[
          I_gB(
            Psi_0x,
            Psi_0ls[Psi_0x * Psi_0jg1s + 1 ... Psi_0x * Psi_0jg1s + Psi_0x + 1],
            mod(((count(Psi_0ls) - 1) / Psi_0x) * Psi_0xx, 1)
          ) for Psi_0jg1s = [0 ... (count(Psi_0ls) - 1) / Psi_0x - 1]
        ][floor(Psi_0xx(count(Psi_0ls) - 1) / Psi_0x) + 1]
    } @{ color: "#388c46" }
} @{ secret: true, collapsed: true }

folder "libracomp -- docs" {
  "use https://gist.github.com/jared-hughes/1bab5d94e2ad0ab326180a21e3f955c0 to bypass nesting limits"

  "[don't use Ψ with a subscript starting with 0 and containing a letter == such variables are used to define libracomp functions]"

  "--------------------------------------------"

  "Complex-Extended Functions"

  "(C with subscript)"

  "= Unary Geometric"

  "> arg(z): argument of z "

  "> abs(z): absolute value of z"

  "> cnj(z): complex conjugate of z"

  "= Trig"

  "> sin(z): sine of z"

  "> cos(z): cosine of z"

  "> tan(z): tangent of z"

  "> cot(z): cotangent of z"

  "> sec(z): secant of z"

  "> csc(z): cosecant of z"

  "= Hypertrig"

  "> sinh(z): hyperbolic sine of z"

  "> cosh(z): hyperbolic cosine of z"

  "> tanh(z): hyperbolic tangent of z"

  "> coth(z): hyperbolic cotangent of z"

  "> sech(z): hyperbolic secant of z"

  "> csch(z): hyperbolic cosecant of z"

  "= Inverse Trig"

  "> asin(z): arcsine of z"

  "> acos(z): arccosine of z"

  "> atan(z): arctangent of z"

  "> acot(z): arccotangent of z"

  "> asec(z): arcsecant of z"

  "> acsc(z): arccosecant of z"

  "= Inverse Hypertrig"

  "> asinh(z): hyperbolic arcsine of z"

  "> acosh(z): hyperbolic arccosine of z"

  "> atanh(z): hyperbolic arctangent of z"

  "> acoth(z): hyperbolic arccotangent of z"

  "> asech(z): hyperbolic arcsecant of z"

  "> acsch(z): hyperbolic arccosecant of z"

  "= Arithmetic"

  "> pdt(z,w): z*w"

  "> qnt(z,w): z/w"

  "= Algebra"

  "> exp(z): eᶻ"

  "> plg(z): principal branch of complex ln"

  "> log(z,w): logᵥᵥ(z)"

  "> pow(z,w): zʷ"

  "= Misc"

  "> gma(z): gamma function of z"

  "> flat(z): flatsine of z"

  " "

  "Real-Extended Functions"

  "(R with subscript)"

  "= Misc"

  "> gma(x): gamma function of x"

  "> dgm(x): digamma function of x"

  "> flat(x): flatsine of x"

  "> bet(x): beta function of x"

  " "

  "Interpolation"

  "(I with subscript)"

  "= Bezier Curves"

  "> B3: Cubic Bezier"

  "∟> B3(P1, P2, P3, P4, t), where Pn - control point n, t - time value"

  "> gB: n-Order Bezier"

  "∟> gB(n, P, t), where n - order, P - control point set, t - time value"

  "> rB: n-Order Rational Bezier"

  "∟> rB(n, P, w, t), where n - order, P - control point set, w - control weight set, t - time value"

  "> sB: n-Order Bezier Spline"

  "∟> sB(n, P, t), where n - order, P - control point set, t - time value"

  "> rsB: n-Order Rational Bezier Spline"

  "∟> rsB(n, P, w, t), where n - order, P - control point set, w - weight values, t - time value"

  "> sBp: m Samples of n-Order Bezier"

  "∟> sBp(n, P, m), where n - order, P - control point set, m - sample amount"

  "> rsBp: m Samples of n-Order Rational Bezier"

  "∟> rsBp(n, P, w, m), where n - order, P - control point set, w - control weight set, m - sample amount"

  "> 3BcV: Control segments of Cubic Bezier"

  "∟> 3BcV(P, m), where P - control point set, t - time value"

  "= Misc"

  "> M: Characteristic Matrix Spline"

  "∟> M(M, P, t), where M - Char. Matrix, P - control point set, t - time value"

  "> nM: Generalized Characteristic Matrix Spline"

  "∟> nM(M, P, t), where M - Char. Matrix (can be any), P - control point set (length same as matrix width), t - time value"

  "> nM3: Generalized 3d Characteristic Matrix Spline"

  "∟> nM3(M, P, t), where M - Char. Matrix (can be any), P - 3d control point set (number of points same as matrix width, made by calling M_StMl(join(),3) on all points in order inside of join()), t - time value"

  "> NURBS: NURBS"

  "∟> NURBS(P, k, w, t), where P - control point set, k - knot value set, w - weight set, t - time value (length of P = length of w = length of k - 1)"

  "> cd: Cardinal Spline"

  "∟> cd(P, s, t), where P - control point set, s - scale parameter, t - time value"

  "> L: Linear Interpolation"

  "∟> L(P1, P2, t), where P1 - starting point, P2 - \nendpoint set, t - time value"

  "> mL: Piecewise Linear Interpolation"

  "∟> mL(P, t), where P - control point set, t - time value"

  "> S: Smoothstep"

  "∟> S(t), where t - time value"

  "> iS: Inverse Smoothstep"

  "∟> iS(x), where x - smoothstep value"

  "> pfs: Partial Fourier Series"

  "∟> pfs(S, t), where S - coefficient set, t - time value"

  "> pfc: Partial Fourier Components"

  "∟> pfc(S, t), where S - coefficient set, t - time value"

  "> fs: Fourier Series"

  "∟> fs(S, i, t), where S - coefficient set, i - static coefficient index, t - time value"

  "> fc: Fourier Components"

  "∟> fc(S, i, t), where S - coefficient set, i - static coefficient index, t - time value"

  " "

  "Matrices"

  "(M with subscript)"

  "= Boolean Output"

  "> S: Check if Matrix is square"

  "> V: Check if Matrix is valid"

  "> v: check if Matrix is vector"

  "= Matrix Properties"

  "> i: Get Matrix Element by Coordinate"

  "∟> i(M, P), where M - matrix, P - coordinate"

  "> c: Specific Column of Matrix"

  "∟> c(M, n), where M - input matrix, n - column index"

  "> r: Specific Row of Matrix"

  "∟> r(M, n), where M - input matrix, n - row index"

  "> Vm: Get Vector Magnitude"

  "> L: Get Matrix Length"

  "> h: Get Matrix Height"

  "> l: Get Matrix Width"

  "> sar: Sarrus Determinant of Square Matrix"

  "> det2: Determinant of Length 2 Square Matrix"

  "> det3: Determinant of Length 3 Square Matrix"

  "> det4: Determinant of Length 4 Square Matrix"

  "   ...."

  "> det10: Determinant of Length 10 Square Matrix"

  "> conj: Conjugate of Matrix"

  "> conjT: Conjugate Transpose of Matrix"

  "= Matrix Conversions"

  "> MtS: Convert Matrix to Array"

  "∟> MtS(M), where M - input matrix"

  "> StM: Convert Array to Matrix"

  "∟> StM(S, h), where S - input array, h - output matrix height"

  "> StMl: Convert Array to Matrix by length"

  "∟> StM(S, l), where S - input array, l - output matrix length"

  "> StV: Convert Array to Vector"

  "∟> StV(S), where S - input array"

  "> OPtV: Convert Ordered Pair to Vector"

  "∟> OPtV(O), where O - input pair"

  "> VtOP: Convert Vector to Ordered Pair"

  "∟> VtOP(V), where V - input 2D vector"

  "> W2: 2D Rotation Matrix"

  "∟> W2(θ), where θ - angle of rotation"

  "> W3: 3D Euler Angle Rotation Matrix"

  "∟> W3(φ, θ, ψ), where φ, θ, ψ - Euler angles of rotation"

  "= Matrix Operations"

  "> pdt: Multiply Matrices"

  "> pdt2: Multiply 2d Square Matrices"

  "> pdt3: Multiply 3d Square Matrices"

  "> sum: Add Matrices"

  "> dif: Substract Matrices"

  "> dpdt: Dot Product"

  "> cpdt: Cross Product"

  "> wpdt: Wedge Product"

  "> tpdt: Tilt Product"

  "> T: Transpose Matrix"

  "> exph: Expand Matrix by Height"

  "> expl: Expand Matrix by Length"

  " > rr: Remove Matrix Row"

  "∟> rr(M, n), where M - matrix, n - row index"

  " > rc: Remove Matrix Column"

  "∟> rc(M, n), where M - matrix, n - column index"

  "> vt2: Transform 2d Vector"

  "∟> vt2(v, M), where v - vector, M - transformation matrix"

  "> vt3: Transform 3d Vector"

  "∟> vt3(v, M), where v - vector, M - transformation matrix"

  " "

  "Constants"

  "(Lowercase Greek letters)"

  "= \"Special\" Constants"

  "> γ\\gamma: Euler-Mascheroni Constant"

  "= Radical-definable Constants"

  "> φ\\phi: Golden Ratio"

  "> ψ\\psi: Supergolden Ratio"

  "> δ\\delta: Silver Ratio"

  "> i: Imaginary Unit"

  "> R: Real Unit"

  " "

  "Projection Tools"

  "(P with subscript)"

  "= Projections"

  "> proj - perspective projection "

  "∟> proj(a, b, S, r, m), where a - 3D point, b - camera cartesian offset, S - camera spherical coordinates, r - camera roll, m - camera zoom"

  "= Transformations"

  "> rotq - quaternion rotation"

  "∟> rotq(a, b, θ), where a - 3D point, b - 3D normalized rotation vector, θ - angle"

  "> pc - 2D cartesian to polar"

  "> cp - 2D polar to cartesian"

  "> pS - inverse stereographic from polar"

  "> r1Sp - spherical projection to polar"

  "> SC - spherical to 3D cartesian"

  "∟> SC([φ, θ, r]), where r - radial distance, θ - azimuthal angle, φ - polar angle"

  "> CS - 3D cartesian to spherical"

  " "

  "Extra"

  "(E with subscript)"

  "= Expansions"

  "> bexp(a, b, p) - binomial expansion of (a + b)ᵖ"

  "> cbexp(z, w, p) - bin. expansion of complex (z + w)ᵖ"

  "--------------------------------------------"

  "libracomp\nBy SlyceDF, v1.4.5;\nfrom https://github.com/SlyceDF/desmos/"
} @{ collapsed: true }
